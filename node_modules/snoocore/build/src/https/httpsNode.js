'use strict';

var _interopRequireWildcard = function (obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (typeof obj === 'object' && obj !== null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } };

var _interopRequireDefault = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

/*
   Form data can be a raw string, or an object containing key/value pairs
 */
exports['default'] = https;
//
// Node requests
//

var _httpsLib = require('https');

var _httpsLib2 = _interopRequireDefault(_httpsLib);

var _urlLib = require('url');

var _urlLib2 = _interopRequireDefault(_urlLib);

var _when = require('when');

var _when2 = _interopRequireDefault(_when);

var _import = require('./form');

var form = _interopRequireWildcard(_import);

// Set to true to print useful http debug information on a lower level
var DEBUG_LOG = false ? console.error : function () {};
function https(options, formData) {
  DEBUG_LOG('\n\n\n\n');
  DEBUG_LOG('>>> request:\n' + options.method + ': ' + options.hostname + options.path);

  options = options || {};
  options.headers = options.headers || {};

  formData = formData || [];

  var data = form.getData(formData);

  options.headers['Content-Type'] = data.contentType;

  if (options.method !== 'GET') {
    options.headers['Content-Length'] = data.contentLength;
  }

  DEBUG_LOG('\n>>> request headers\n', options.headers);

  // stick the data at the end of the url for GET requests
  if (options.method === 'GET' && data.buffer.toString() !== '') {
    DEBUG_LOG('\n>>> query string:\n', data.buffer.toString());
    options.path += '?' + data.buffer.toString();
  }

  return _when2['default'].promise(function (resolve, reject) {

    var req = _httpsLib2['default'].request(options, function (res) {

      res._req = req; // attach a reference back to the request

      res.setEncoding('utf8');
      var body = '';
      res.on('error', function (error) {
        return reject(error);
      });
      res.on('data', function (chunk) {
        body += chunk;
      });
      res.on('end', function () {
        res._body = body; // attach the response body to the object
        res._status = res.statusCode;
        res._headers = res.headers;
        DEBUG_LOG('\n>>> response headers:\n', res._headers);
        DEBUG_LOG('\n>>> response body:\n', String(body).substring(0, 1000));
        DEBUG_LOG('\n>>> status:\n', res.statusCode);
        return resolve(res);
      });
    });

    if (options.method !== 'GET') {
      DEBUG_LOG('\n>>> request body:\n', data.buffer.toString());
      req.write(data.buffer);
    }

    req.end();
  }).then(function (res) {
    var canRedirect = String(res._status).substring(0, 1) === '3' && typeof res._headers.location !== 'undefined';

    if (canRedirect) {
      // Make the call again with the new hostname, path, and form data
      var parsed = _urlLib2['default'].parse(res._headers.location);
      options.hostname = parsed.hostname;
      options.path = parsed.pathname;
      return https(options, parsed.query);
    }

    return res;
  });
}

module.exports = exports['default'];
//# sourceMappingURL=../https/httpsNode.js.map