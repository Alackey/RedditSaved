'use strict';

var _interopRequireDefault = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

// node modules

var _util = require('util');

var _util2 = _interopRequireDefault(_util);

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _urlLib = require('url');

var _urlLib2 = _interopRequireDefault(_urlLib);

// npm modules

var _when = require('when');

var _when2 = _interopRequireDefault(_when);

var _delay = require('when/delay');

var _delay2 = _interopRequireDefault(_delay);

var _he = require('he');

var _he2 = _interopRequireDefault(_he);

// our modules

var _Request = require('./Request');

var _Request2 = _interopRequireDefault(_Request);

var _Endpoint = require('./Endpoint');

var _Endpoint2 = _interopRequireDefault(_Endpoint);

var _ResponseError = require('./ResponseError');

var _ResponseError2 = _interopRequireDefault(_ResponseError);

/*
   A collection of functions that deal with requesting data from the
   reddit API.
 */

var RedditRequest = (function (_events$EventEmitter) {
  function RedditRequest(userConfig, request, oauth, oauthAppOnly) {
    _classCallCheck(this, RedditRequest);

    _get(Object.getPrototypeOf(RedditRequest.prototype), 'constructor', this).call(this);
    this._request = request;
    this._userConfig = userConfig;
    this._oauth = oauth;
    this._oauthAppOnly = oauthAppOnly;
  }

  _inherits(RedditRequest, _events$EventEmitter);

  _createClass(RedditRequest, [{
    key: 'isApplicationOnly',

    /*
       Currently application only?
        If we do not have an access token and there is no way
       to get a new access token then yes! We are application
       only oauth.
     */
    value: function isApplicationOnly() {
      return !this._oauth.hasAccessToken() && !this._oauth.canRefreshAccessToken();
    }
  }, {
    key: 'isAuthenticated',

    /*
       Are we currently authenticated?
     */
    value: function isAuthenticated() {
      return this.isApplicationOnly() ? this._oauthAppOnly.hasAccessToken() : this._oauth.hasAccessToken();
    }
  }, {
    key: 'buildHeaders',

    /*
       Builds up the headers for an endpoint.
     */
    value: function buildHeaders() {
      var contextOptions = arguments[0] === undefined ? {} : arguments[0];

      var headers = {};

      if (this._userConfig.isNode) {
        // Can't set User-Agent in browser
        headers['User-Agent'] = this._userConfig.userAgent;
      } else if (this._userConfig.useBrowserCookies) {
        // But the admins might appreciate this
        headers['X-User-Agent'] = this._userConfig.userAgent;
      }

      if (!this._userConfig.useBrowserCookies) {
        if (contextOptions.bypassAuth || this.isApplicationOnly()) {
          headers.Authorization = this._oauthAppOnly.getAuthorizationHeader();
        } else {
          headers.Authorization = this._oauth.getAuthorizationHeader();
        }
      }

      return headers;
    }
  }, {
    key: 'callRedditApi',

    /*
       Call the reddit api.
     */
    value: function callRedditApi(endpoint) {
      var _this = this;

      // Authenticate if needed before making a call.
      //
      // Eliminates unwanted 401 errors when making initial calls
      // on Application only OAuth & Script instances where calling
      // `.auth()` isn't required.
      var auth = this.isAuthenticated() ? _when2['default'].resolve() : (function () {
        return _this.authenticate(endpoint).then(function () {
          // rebuild endpoint with new headers
          endpoint = new _Endpoint2['default'](_this._userConfig, endpoint.hostname, endpoint.method, endpoint.path, _this.buildHeaders(endpoint.contextOptions), endpoint.givenArgs, endpoint.contextOptions, endpoint.port);
        });
      })();

      return auth.then(function () {
        var requestPromise = _this._request.https(endpoint, _this.responseErrorHandler.bind(_this));

        return requestPromise.then(function (response) {
          return _this.handleSuccessResponse(response, endpoint);
        });
      });
    }
  }, {
    key: 'authenticate',

    /*
       Authenticate with the appropriate OAuth type for a given
       endpoint
     */
    value: function authenticate(endpoint) {
      var authPromise = undefined;

      // If we are application only, or are bypassing authentication
      // therefore we're using application only OAuth
      if (this._userConfig.useBrowserCookies) {
        authPromise = _when2['default'].resolve();
      } else if (this.isApplicationOnly() || endpoint.contextOptions.bypassAuth) {
        authPromise = this._oauthAppOnly.applicationOnlyAuth();
      } else if (this._oauth.canRefreshAccessToken()) {
        // If we have been authenticated with a permanent refresh token use it
        if (this._oauth.hasRefreshToken()) {
          authPromise = this._oauth.refresh();
        }
        // If we are OAuth type script we can call `.auth` again
        else if (this._userConfig.isOAuthType('script')) {
          authPromise = this._oauth.auth();
        }
      }
      // No way to authenticate
      else {
        return _when2['default'].reject(new Error('Unable to authenticate'));
      }

      return authPromise;
    }
  }, {
    key: 'responseErrorHandler',

    /*
       Handle a request errors from reddit. This is usually caused when our
       access_token has expired, or reddit servers are under heavy load.
        If we can't renew our access token, we throw an error / emit the
       'access_token_expired' event that users can then handle to
       re-authenticatet clients
        If we can renew our access token, we try to reauthenticate, and call the
       reddit endpoint again.
     */
    value: function responseErrorHandler(response, endpoint) {
      var _this2 = this;

      // - - -
      // Check headers for more specific errors.

      var wwwAuth = response._headers['www-authenticate'];

      if (wwwAuth && wwwAuth.indexOf('insufficient_scope') !== -1) {
        return _when2['default'].reject(new _ResponseError2['default']('Insufficient scopes provided for this call', response, endpoint));
      }

      // - - -
      // 404 - Page not found
      if (response._status === 404) {
        var msg = 'Page not found. Is this a valid endpoint?';
        return _when2['default'].reject(new _ResponseError2['default'](msg, response, endpoint));
      }

      // - - -
      // Access token has expired
      if (response._status === 401 && !this._userConfig.useBrowserCookies) {

        // Atempt to get a new access token!
        var reauthPromise = this.authenticate(endpoint);

        return reauthPromise.then(function () {
          // refresh the authentication headers for this endpoint
          endpoint.setHeaders(_this2.buildHeaders(endpoint.contextOptions));

          var modifiedEndpoint = new _Endpoint2['default'](_this2._userConfig, endpoint.hostname, endpoint.method, endpoint.path, _this2.buildHeaders(endpoint.contextOptions), endpoint.givenArgs, endpoint.contextOptions, endpoint.port);

          return _when2['default'].resolve(modifiedEndpoint);
        })['catch'](function (error) {
          _this2.emit('access_token_expired');

          var msg = 'Access token has expired. Listen for ' + 'the "access_token_expired" event to ' + 'handle this gracefully in your app.';
          return _when2['default'].reject(new _ResponseError2['default'](msg, response, endpoint));
        });
      }

      // - - -
      // Access token has expired and we're trying to authenticate without OAuth
      if (response._status === 401 && !this._userConfig.useBrowserCookies) {
        var msg = 'Access token required to access this endpoint.';
        return _when2['default'].reject(new _ResponseError2['default'](msg, response, endpoint));
      }

      // - - -
      // Reddit servers are busy. Can't do much here.

      if (String(response._status).substring(0, 1) === '5') {
        var modifiedEndpoint = new _Endpoint2['default'](this._userConfig, endpoint.hostname, endpoint.method, endpoint.path, this.buildHeaders(endpoint.contextOptions), endpoint.givenArgs, endpoint.contextOptions, endpoint.port);

        return _when2['default'].resolve(modifiedEndpoint);
      }

      // - - -
      // At the end of the day, we just throw an error stating that there
      // is nothing we can do & give general advice
      return _when2['default'].reject(new _ResponseError2['default']('This call failed. ' + 'Does this call require a user? ' + 'Is the user missing reddit gold? ' + 'Trying to change a subreddit that the user does not moderate? ' + 'This is an unrecoverable error. Check the rest of the ' + 'error message for more information.', response, endpoint));
    }
  }, {
    key: 'handleSuccessResponse',

    /*
       Handle reddit response status of 2xx.
        Finally return the data if there were no problems.
     */
    value: function handleSuccessResponse(response, endpoint) {

      var data = response._body || '';

      if (endpoint.contextOptions.decodeHtmlEntities) {
        data = _he2['default'].decode(data);
      }

      // Attempt to parse some JSON, otherwise continue on (may be empty, or text)
      try {
        data = JSON.parse(data);

        // Reddit isn't always honest in their response status. Check for
        // any errors in 2xx http statuses

        // data.json.errors
        if (data.json && data.json.errors && data.json.errors.length > 0) {
          return _when2['default'].reject(new _ResponseError2['default']('', response, endpoint));
        }

        // data.json.error
        if (data.json && data.json.error) {
          return _when2['default'].reject(new _ResponseError2['default']('', response, endpoint));
        }
      } catch (e) {}

      var rateLimitRemaining = response._headers['x-ratelimit-remaining'];
      var rateLimitUsed = response._headers['x-ratelimit-used'];
      var rateLimitReset = response._headers['x-ratelimit-reset'];

      var rateLimitData = {
        rateLimitRemaining: rateLimitRemaining ? Number(rateLimitRemaining) : void 0,
        rateLimitUsed: rateLimitUsed ? Number(rateLimitUsed) : void 0,
        rateLimitReset: rateLimitReset ? Number(rateLimitReset) : void 0
      };

      if (typeof rateLimitData.rateLimitUsed !== 'undefined') {
        this.emit('rate_limit', rateLimitData);
      }

      // Using a test variable
      // this._userConfig.__test.rateLimitRemainingCutoff
      // it's default value is "0", however in the tests cases this
      // would take too long.
      var cutoff = this._userConfig.__test.rateLimitRemainingCutoff;

      if (typeof rateLimitData.rateLimitRemaining !== 'undefined' && Number(rateLimitRemaining) <= cutoff) {
        this.emit('rate_limit_reached', rateLimitData);
      }

      return _when2['default'].resolve(data);
    }
  }, {
    key: 'getListing',

    /*
       Listing support.
     */
    value: function getListing(endpoint) {
      var _this3 = this;

      // number of results that we have loaded so far. It will
      // increase / decrease when calling next / previous.
      var count = 0;
      var limit = endpoint.args.limit || 25;
      // keep a reference to the start of this listing
      var start = endpoint.args.after || null;

      var getSlice = (function (_getSlice) {
        function getSlice(_x) {
          return _getSlice.apply(this, arguments);
        }

        getSlice.toString = function () {
          return _getSlice.toString();
        };

        return getSlice;
      })(function (endpoint) {

        return _this3.callRedditApi(endpoint).then(function () {
          var result = arguments[0] === undefined ? {} : arguments[0];

          var slice = {};
          var listing = result;

          slice.get = result;

          if (result instanceof Array) {
            if (typeof endpoint.contextOptions.listingIndex === 'undefined') {
              throw new Error('Must specify a `listingIndex` for this listing.');
            }

            listing = result[endpoint.contextOptions.listingIndex];
          }

          slice.count = count;

          slice.before = listing.data.before || null;
          slice.after = listing.data.after || null;
          slice.allChildren = listing.data.children || [];

          slice.empty = slice.allChildren.length === 0;

          slice.children = slice.allChildren.filter(function (child) {
            child.data = child.data || {};
            return !child.data.stickied;
          });

          slice.stickied = slice.allChildren.filter(function (child) {
            child.data = child.data || {};
            return child.data.stickied;
          });

          slice.next = function () {
            count += limit;

            var newArgs = endpoint.givenArgs;
            newArgs.before = null;
            newArgs.after = slice.children[slice.children.length - 1].data.name;
            newArgs.count = count;
            return getSlice(new _Endpoint2['default'](_this3._userConfig, endpoint.hostname, endpoint.method, endpoint.path, _this3.buildHeaders(endpoint.contextOptions), newArgs, endpoint.contextOptions, endpoint.port));
          };

          slice.previous = function () {
            count -= limit;

            var newArgs = endpoint.givenArgs;
            newArgs.before = slice.children[0].data.name;
            newArgs.after = null;
            newArgs.count = count;
            return getSlice(new _Endpoint2['default'](_this3._userConfig, endpoint.hostname, endpoint.method, endpoint.path, _this3.buildHeaders(endpoint.contextOptions), newArgs, endpoint.contextOptions, endpoint.port));
          };

          slice.start = function () {
            count = 0;

            var newArgs = endpoint.givenArgs;
            newArgs.before = null;
            newArgs.after = start;
            newArgs.count = count;
            return getSlice(new _Endpoint2['default'](_this3._userConfig, endpoint.hostname, endpoint.method, endpoint.path, _this3.buildHeaders(endpoint.contextOptions), newArgs, endpoint.contextOptions, endpoint.port));
          };

          slice.requery = function () {
            return getSlice(endpoint);
          };

          return slice;
        });
      });

      return getSlice(endpoint);
    }
  }, {
    key: 'path',

    /*
       Enable path syntax support, e.g. this.path('/path/to/$endpoint/etc')
        Can take an url as well, but the first part of the url is chopped
       off because it is not needed. We will always use the server oauth
       to call the API...
        e.g. https://www.example.com/api/v1/me
        will only use the path: /api/v1/me
     */
    value: (function (_path) {
      function path(_x2) {
        return _path.apply(this, arguments);
      }

      path.toString = function () {
        return _path.toString();
      };

      return path;
    })(function (urlOrPath) {
      var _this4 = this;

      var parsed = _urlLib2['default'].parse(urlOrPath);
      var path = parsed.pathname;

      var calls = {};

      ['get', 'post', 'put', 'patch', 'delete', 'update'].forEach(function (verb) {
        calls[verb] = function (userGivenArgs, userContextOptions) {
          return _this4.callRedditApi(new _Endpoint2['default'](_this4._userConfig, _this4._userConfig.serverOAuth, verb, path, _this4.buildHeaders(userContextOptions), userGivenArgs, userContextOptions, _this4._userConfig.serverOAuthPort));
        };
      });

      // Add listing support
      calls.listing = function (userGivenArgs, userContextOptions) {
        return _this4.getListing(new _Endpoint2['default'](_this4._userConfig, _this4._userConfig.serverOAuth, 'get', path, _this4.buildHeaders(userContextOptions), userGivenArgs, userContextOptions, _this4._userConfig.serverOAuthPort));
      };

      return calls;
    })
  }]);

  return RedditRequest;
})(_events2['default'].EventEmitter);

exports['default'] = RedditRequest;
module.exports = exports['default'];
//# sourceMappingURL=RedditRequest.js.map