'use strict';

var _interopRequireWildcard = function (obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (typeof obj === 'object' && obj !== null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } };

var _interopRequireDefault = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

Object.defineProperty(exports, '__esModule', {
  value: true
});

/*
   Takes an url, and an object of url parameters and replaces
   them, e.g.

   endpointUrl:
   'http://example.com/$foo/$bar/test.html'

   this.givenArgs: { $foo: 'hello', $bar: 'world' }

   would output:

   'http://example.com/hello/world/test.html'
 */
exports.replaceUrlParams = replaceUrlParams;

var _urlLib = require('url');

var _urlLib2 = _interopRequireDefault(_urlLib);

var _import = require('./utils');

var u = _interopRequireWildcard(_import);

var Endpoint = (function () {
  function Endpoint(userConfig, hostname, method, path) {
    var headers = arguments[4] === undefined ? {} : arguments[4];
    var givenArgs = arguments[5] === undefined ? {} : arguments[5];
    var givenContextOptions = arguments[6] === undefined ? {} : arguments[6];
    var port = arguments[7] === undefined ? 80 : arguments[7];

    _classCallCheck(this, Endpoint);

    this._userConfig = userConfig;

    this.hostname = hostname;
    this.port = port;
    this.method = method;
    this.path = path;
    this.headers = headers;

    this.contextOptions = this.normalizeContextOptions(givenContextOptions);

    this.givenArgs = givenArgs;
    this.args = this.buildArgs();
    this.url = this.buildUrl();
    this.computedPath = _urlLib2['default'].parse(this.url).path;
  }

  _createClass(Endpoint, [{
    key: 'setHeaders',
    value: function setHeaders(headers) {
      this.headers = headers;
    }
  }, {
    key: 'normalizeContextOptions',

    /*
       Returns a set of options that effect how each call to reddit behaves.
     */
    value: function normalizeContextOptions(givenContextOptions) {

      var cOptions = givenContextOptions || {};

      // by default we do not bypass authentication
      cOptions.bypassAuth = u.thisOrThat(cOptions.bypassAuth, false);

      // decode html enntities for this call?
      cOptions.decodeHtmlEntities = u.thisOrThat(cOptions.decodeHtmlEntities, this._userConfig.decodeHtmlEntities);

      // how many attempts left do we have to retry an endpoint?

      // use the given retryAttemptsLeft, or the retryAttempts passed in the
      // context options if not specified
      cOptions.retryAttemptsLeft = u.thisOrThat(cOptions.retryAttemptsLeft, cOptions.retryAttempts);

      // use the given retryAttemptsLeft, or the retryAttempts passed in the
      // user configuration
      cOptions.retryAttemptsLeft = u.thisOrThat(cOptions.retryAttemptsLeft, this._userConfig.retryAttempts);

      // delay between retrying an endpoint
      cOptions.retryDelay = u.thisOrThat(cOptions.retryDelay, this._userConfig.retryDelay);

      // milliseconds before a request times out
      cOptions.requestTimeout = u.thisOrThat(cOptions.requestTimeout, this._userConfig.requestTimeout);

      // how many reauthentication attempts do we have left?
      cOptions.reauthAttemptsLeft = u.thisOrThat(cOptions.reauthAttemptsLeft, cOptions.retryAttemptsLeft);

      return cOptions;
    }
  }, {
    key: 'buildArgs',

    /*
       Build the arguments that we will send to reddit in our
       request. These customize the request that we send to reddit
     */
    value: function buildArgs() {
      var args = {};

      // Skip any url parameters (e.g. items that begin with $)
      for (var key in this.givenArgs) {
        if (key.substring(0, 1) !== '$') {
          args[key] = this.givenArgs[key];
        }
      }

      var apiType = u.thisOrThat(this.contextOptions.api_type, this._userConfig.apiType);

      if (apiType) {
        args.api_type = apiType;
      }

      return args;
    }
  }, {
    key: 'buildUrl',

    /*
       Builds the URL that we will query reddit with.
     */
    value: function buildUrl() {
      var url = this.hostname;

      if (this.port !== 80) {
        url += ':' + this.port;
      }

      var path = this.path;
      if (path.substring(0, 1) !== '/') {
        path = '/' + path;
      }

      url += path;

      url = replaceUrlParams(url, this.givenArgs);
      url = url.replace('//', '/');
      url = 'https://' + url;
      return url;
    }
  }]);

  return Endpoint;
})();

exports['default'] = Endpoint;

function replaceUrlParams(endpointUrl, givenArgs) {
  // nothing to replace!
  if (endpointUrl.indexOf('$') === -1) {
    return endpointUrl;
  }

  // pull out variables from the url
  var params = endpointUrl.match(/\$[\w\.]+/g);

  // replace with the argument provided
  params.forEach(function (param) {
    if (typeof givenArgs[param] === 'undefined') {
      throw new Error('missing required url parameter ' + param);
    }
    endpointUrl = endpointUrl.replace(param, givenArgs[param]);
  });

  return endpointUrl;
}
//# sourceMappingURL=Endpoint.js.map